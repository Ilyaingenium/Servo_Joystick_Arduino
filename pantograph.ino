#define F_CPU 1000000UL	
#include <avr/io.h>		
#include <stdio.h>		
#include <util/delay.h>

void PWM_settings_1 (void)
{
	TCCR1A |= (1<<COM1A1);
	TCCR1A &= ~(1<<COM1A0); // НЕинвертирующая  быстродействующая ШИМ- пилообразная форма импульсов опорного напряжения

	TCCR1A |= (1<<WGM10); // 8 бит ШИМ, быстро действ.
	TCCR1A &= ~(1<<WGM11); // 8 бит ШИМ, быстро действ.
	TCCR1B |= (1<<WGM12); // 8 бит ШИМ, быстро действ.
	TCCR1B &= ~(1<<WGM13); // 8 бит ШИМ, быстро действ.

	TCCR1B |= (1<<CS11); // Делим частоту МК на 8
	TCCR1B &= ~((1<<CS10)|(1<<CS12)); // Делим частоту МК на 8 = 125000
	// timer counter control register (0 pin B-настраиваемый, 8-битный) делим частоту счетчика на (8*1024)/1000000=0,008 сек . Частота = 1024\0,008
	// 1000000 / (8*1024)=122 частота работы шим
}

void PWM_settings_2 (void)
{
	TCCR1A |= (1<<COM1B1); // НЕинвертирующая  быстродействующая ШИМ- пилообразная форма импульсов опорного напряжения
	TCCR1A &= ~ (1<<COM1B0);
	
	TCCR1A |= (1<<WGM10); // 8 бит ШИМ, быстро действ.
	TCCR1A &= ~(1<<WGM11); // 8 бит ШИМ, быстро действ.
	TCCR1B |= (1<<WGM12); // 8бит ШИМ, быстро действ.
	TCCR1B &= ~(1<<WGM13); // 8 бит ШИМ, быстро действ.

	TCCR1B |= (1<<CS11); // Делим частоту МК на 8
	TCCR1B &= ~((1<<CS10)|(1<<CS12)); // Делим частоту МК на 8 = 125000
	// timer counter control register (0 pin B-настраиваемый, 8-битный) делим частоту счетчика на (8*1024)/1000000=0,008 сек . Частота = 1024\0,008
	// 1000000 / (8*1024)=122 частота работы шим
}

void PWM_settings_3 (void)
{
	TCCR0A |= (1<<COM0A1);
	TCCR0A &= ~ (1<<COM0A0); // НЕинвертирующая ШИМ
		
	TCCR0A |= (1<<WGM00); // 8 бит ШИМ, быстро действ.
	TCCR0A |= (1<<WGM01); // 8 бит ШИМ, быстро действ.
	TCCR0B &= ~ (1<<WGM02); // 8 бит ШИМ, быстро действ.
	
	TCCR0B &= ~((1<<CS00) | (1<<CS02)); // Делим частоту МК на 8
	TCCR0B |= (1<<CS01); // Делим частоту МК на 8
	
	}

void PWM_settings_4 (void)
{
	TCCR0A |= (1<<COM0B1);
	TCCR0A &= ~ (0<<COM0B0); // НЕинвертирующая ШИМ
		
	TCCR0A |= (1<<WGM00); // 8 бит ШИМ, быстро действ.
	TCCR0A |= (1<<WGM01); // 8 бит ШИМ, быстро действ.
	TCCR0B &= ~ (1<<WGM02); // 8 бит ШИМ, быстро действ.
	
	TCCR0B &= ~((1<<CS00) | (1<<CS02)); // Делим частоту МК на 8
	TCCR0B |= (1<<CS01); // Делим частоту МК на 8
	
}

void ADC_Init()	
{
	ADMUX |= (1<<REFS0); // Опорное напряжение - внешние 5 В
	ADMUX &= ~(1<<REFS1);
	
	ADMUX &= ~(1<<ADLAR); // Правостороннее выравнивание
	
	ADMUX &= ~((1<<MUX3) | (1<<MUX2) | (1<<MUX1)| (1<<MUX0));// Задействуем 0-й вывод АЦП (РС0)
	//ADMUX |= (1<<MUX0);
	
	ADCSRA |= (1<<ADEN); // Разрешаем работу АЦП

	ADCSRA |= (1<<ADATE); // Режим непрырывного измерения
	
	ADCSRA &= ~(1<<ADPS2); //делим частоту Мк на 8 - Устанавливаем частоту преобразования АЦП 125 000 Гц такие цифры нужны чтобы более точно отслеживать изменения (рекомендуется от 50 до 200 КГц)
	ADCSRA |= (1<<ADPS1) | (1<<ADPS0);
}

int ADC_Read(char channel)
{
	ADMUX = 0x40 | (channel & 0x03); //считывание показателей с разных пинов 1 и 0
	ADCSRA |= (1<<ADSC); // Запуск преобразования АЦП
	
	while (!(ADCSRA & (1<<ADIF))); // проверяем наличие 1 в реестре. Если 0, то начинаем считывание ацп.
	ADCSRA |= (1<<ADIF); // устанавливаем бит в 1, останавливаем работу АЦП. В ноль сбросится сам через несколько тактов.
	_delay_ms(0);
	return ADC;	
}

int main(void)
{
		PWM_settings_1 ();
		PWM_settings_2 ();
		PWM_settings_3 ();
		PWM_settings_4 ();

	ADC_Init();		
		
	//Вход АЦП
	// DDRC &= ~(1<<0);
	// DDRC &= ~(1<<1);
	
  PORTC= 0b00000011 ;
	while(1)
	{
		
		if(ADC_Read(0)<100)
		{
		DDRB = 0b00000110; // чем ниже ШИМ,тем больше напряжения идет на моторы
    DDRD = 0b00100000;
				OCR1A = 10;
      OCR0A = 10;
		}
        		
		else if((ADC_Read(0)>=115) && (ADC_Read(0)<215))
		{
	DDRB = 0b00000110;
  DDRD = 0b00100000;
			OCR1A = 50;
      OCR0A = 50;
		}
		
		else if ((ADC_Read(0)>=215) && (ADC_Read(0)<315))
		{
		DDRB = 0b00000110;
    DDRD = 0b00100000;
			OCR1A= 70;
      OCR0A= 70;
		}
		else if ((ADC_Read(0)>=315) && (ADC_Read(0)<415))
		{
		DDRB = 0b00000110;
    DDRD = 0b00100000;
			OCR1A = 122;
      OCR0A = 122;
		}
		
		else if ((ADC_Read(0)>=415) && (ADC_Read(0)<=620))
		{
		DDRB = 0b00000110;
    DDRD = 0b00100000; // среднее значение ШИМ, показатель ШИМ и напряжение в рановесии
       OCR1A = 122;
      OCR1B = 122;
		
		}
		
		else if((ADC_Read(0)>=555) && (ADC_Read(0)<615))
		{
		DDRB = 0b00000110;
    DDRD = 0b00100000;
			OCR1B = 130;
      OCR1A = 130;
		}
		
		else if ((ADC_Read(0)>=615) && (ADC_Read(0)<715))
		{
	DDRB = 0b00000110;
  DDRD = 0b00100000;
			OCR1B = 150;
      OCR1A = 150;
		}
				
		else if ((ADC_Read(0)>=715) && (ADC_Read(0)<815))
		{
		DDRB = 0b00000110;
    DDRD = 0b00100000;
			OCR1B= 170;
      OCR1A= 170;
		}
		
		else if ((ADC_Read(0)>=815) && (ADC_Read(0)<915))
		{
	DDRB = 0b00000110;
  DDRD = 0b00100000;
			OCR1B= 190;
      OCR1A= 190;
		}
		
		else if(ADC_Read(0)>=930)
		{
		DDRB = 0b00000110;
    DDRD = 0b00100000;
	OCR1B= 254;
      OCR1A= 254;
		}

	
		 // другой АЦП
     

			else if((ADC_Read(1)>=115) && (ADC_Read(1)<215))
		{
DDRB = 0b00000110;
			OCR1A = 50;
      OCR1B = 50;
		}
		
		else if ((ADC_Read(1)>=215) && (ADC_Read(1)<315))
		{
DDRB = 0b00000110;
			OCR1A= 70;
      OCR1B= 70;
		}
		else if ((ADC_Read(1)>=315) && (ADC_Read(1)<415))
		{
		DDRB = 0b00000110;
			OCR1A = 122;
      OCR1B = 122;
		}
		
		else if ((ADC_Read(1)>=415) && (ADC_Read(1)<=620))
		{
		DDRB = 0b00000110; // среднее значение ШИМ, показатель ШИМ и напряжение в рановесии
       OCR1A = 122;
      OCR1B = 122;
		
		}
		
		else if((ADC_Read(1)>=555) && (ADC_Read(1)<615))
		{
		DDRB = 0b00000110;
			OCR1B = 130;
      OCR1A = 130;
		}
		
		else if ((ADC_Read(1)>=615) && (ADC_Read(1)<715))
		{
		DDRB = 0b00000110;
			OCR1B = 150;
      OCR1A = 150;
		}
				
		else if ((ADC_Read(1)>=715) && (ADC_Read(1)<815))
		{
			DDRB = 0b00000110;
			OCR1B= 180;
      OCR1A= 180;
		}
		
		else if ((ADC_Read(1)>=815) && (ADC_Read(1)<915))
		{
	DDRB = 0b00000110;
			OCR1B= 210;
      OCR1A= 210;
		}
		
		else if(ADC_Read(1)>=930)
		{
		DDRB = 0b00000110;
	
		}
	}
}





